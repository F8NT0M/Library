import json #модуль для работы с JSON-данными
from datetime import datetime #модуль для работы с датами и временем

from book import Book
from reader import Reader
#классы, которые, предположительно, определены в других файлах (book.py и reader.py), и используются для представления книг и читателей соответственно


class Library: #Эта строка определяет новый класс с именем Library, который будет использоваться для управления библиотекой
    def __init__(self): #Это метод инициализации (конструктор) класса Library. Он вызывается автоматически при создании нового объекта этого класса
        """Класс для управления библиотекой."""
        self.books = [] #Эта строка инициализирует атрибут экземпляра self.books как пустой список. Этот список будет хранить все книги, доступные в библиотеке
        self.readers = [] #Аналогично предыдущей строке, эта строка инициализирует атрибут экземпляра self.readers как пустой список. Этот список будет хранить всех читателей, зарегистрированных в библиотеке

    def add_book(self, book): #Это метод, который принимает один параметр book и предназначен для добавления книги в библиотеку
        """Добавляет книгу в библиотеку."""
        self.books.append(book) #Эта строка добавляет переданную книгу (book) в список self.books

    def remove_book(self, title): #Это метод, который принимает один параметр title и предназначен для удаления книги из библиотеки по ее названию
        """Удаляет книгу из библиотеки по названию."""
        self.books = [book for book in self.books if book.title != title]
        #Эта строка создает новый список книг, исключая ту, название которой совпадает с переданным параметром title. Таким образом, книга с указанным названием удаляется из библиотеки

    def update_book(self, title, **kwargs): #Эта строка создает новый список книг, исключая ту, название которой совпадает с переданным параметром title. Таким образом, книга с указанным названием удаляется из библиотеки
        """Обновляет информацию о книге."""
        for book in self.books: #Эта строка начинает цикл, который перебирает все книги в списке self.books
            if book.title == title: #Эта строка проверяет, совпадает ли название текущей книги с переданным параметром title
                book.__dict__.update(kwargs) #Если названия совпадают, эта строка обновляет атрибуты книги с помощью переданных аргументов из kwargs. Это позволяет изменять любые свойства книги

    def add_reader(self, reader): #Это метод, который принимает один параметр reader и предназначен для добавления нового читателя в систему
        """Добавляет нового читателя в систему."""
        self.readers.append(reader) #Эта строка добавляет переданного читателя (reader) в список self.readers

    def remove_reader(self, card_number): #Это метод, который принимает один параметр card_number и предназначен для удаления читателя из системы по номеру читательского билета
        """Удаляет читателя из системы по номеру билета."""
        self.readers = [reader for reader in self.readers if reader.card_number != card_number]
        #Эта строка создает новый список читателей, исключая того, чей номер билета совпадает с переданным параметром card_number. Таким образом, читатель с указанным номером удаляется из системы

    def update_reader(self, card_number, **kwargs): #Это метод, который принимает номер читательского билета (card_number) и произвольное количество дополнительных аргументов (**kwargs), предназначенный для обновления данных читателя
        """Обновляет данные читателя."""
        for reader in self.readers: #Эта строка начинает цикл, который перебирает всех читателей в списке self.readers
            if reader.card_number == card_number: #Эта строка проверяет, совпадает ли номер читательского билета текущего читателя с переданным параметром card_number
                reader.__dict__.update(kwargs) #Если номера совпадают, эта строка обновляет атрибуты читателя с помощью переданных аргументов из kwargs

    def issue_book(self, card_number, book_title): #Это метод, который принимает номер читательского билета (card_number) и название книги (book_title) и предназначен для выдачи книги читателю
        """Выдаёт книгу читателю."""
        reader = next((reader for reader in self.readers if reader.card_number == card_number), None)
        #Эта строка ищет читателя с указанным номером билета. Если читатель не найден, переменной reader будет присвоено значение None
        book = next((book for book in self.books if book.title == book_title), None)
        #Эта строка ищет книгу с указанным названием. Если книга не найдена, переменной book будет присвоено значение None
        if not reader:
            print("Читатель с таким номером не найден.")
            return
        #Если читатель не найден (т.е. reader равен None), выводится сообщение об ошибке и выполнение метода прекращается с помощью команды return
        if not book:
            print("Книга с таким названием не найдена.")
            return
        #Аналогично предыдущему блоку: если книга не найдена (т.е. book равен None), выводится сообщение об ошибке и выполнение метода прекращается
        if book.copies <= 0:
            print("Нет доступных экземпляров книги.")
            return
        #Если количество доступных экземпляров книги меньше или равно нулю (т.е. книга недоступна), выводится сообщение об ошибке и выполнение метода прекращается
        overdue_books = [b for b, date in reader.borrowed_books if (datetime.now() - date).days > 14]
        # Эта строка создает список просроченных книг у читателя. Книги считаются просроченными, если они были выданы более 14 дней назад
        if overdue_books:
            print(f"Читатель имеет просроченные книги: {', '.join(overdue_books)}. Сначала нужно вернуть их.")
            return
        #Если у читателя есть просроченные книги, выводится сообщение с перечислением этих книг и выполнение метода прекращается
        reader.borrowed_books.append((book_title, datetime.now()))
        #Если все проверки пройдены, книга добавляется в список взятых книг читателя вместе с текущей датой выдачи
        book.copies -= 1 #Если все проверки пройдены, книга добавляется в список взятых книг читателя вместе с текущей датой выдачи
        print(f"Книга '{book_title}' успешно выдана читателю {reader.first_name} {reader.last_name}.")
        #Выводится сообщение о том, что книга успешно выдана конкретному читателю

    def reader_report(self, card_number): #Это метод, который принимает номер читательского билета (card_number) и предназначен для генерации отчета о книгах, выданных конкретному читателю
        """Возвращает список книг, выданных читателю."""
        reader = next((reader for reader in self.readers if reader.card_number == card_number), None)
        #Эта строка ищет читателя с указанным номером билета. Если читатель не найден, переменной reader будет присвоено значение None
        return [b[0] for b in reader.borrowed_books] if reader else []
        #Если читатель найден (т.е. reader не равен None), возвращается список названий книг из списка взятых книг этого читателя. Если читатель не найден, возвращается пустой список

    def issued_books_report(self): #Эта строка определяет метод issued_books_report, который не принимает дополнительных параметров, кроме self, ссылающегося на экземпляр класса Library
        """Возвращает отчёт о всех выданных книгах."""
        report = [] #Эта строка инициализирует пустой список report, который будет использоваться для хранения информации о выданных книгах
        for reader in self.readers: #Эта строка начинает цикл, который перебирает всех читателей в списке self.readers
            for book_title, borrow_date in reader.borrowed_books:
            #Внутренний цикл, который перебирает все книги, выданные текущему читателю. Каждая книга представлена в виде кортежа, содержащего название книги (book_title) и дату выдачи (borrow_date)
                report.append({ #Эта строка добавляет новый словарь в список report. Словарь будет содержать информацию о читателе и выданной книге
                    "reader": f"{reader.first_name} {reader.last_name}", #В словаре создается ключ "reader", которому присваивается строка, состоящая из имени и фамилии читателя, объединенных пробелом
                    "book_title": book_title, #В словаре создается ключ "book_title", которому присваивается название выданной книги
                    "borrow_date": borrow_date.strftime("%Y-%m-%d") #В словаре создается ключ "borrow_date", которому присваивается дата выдачи книги в формате "ГГГГ-ММ-ДД". Метод strftime используется для форматирования даты
                })
        return report #Метод возвращает список report, содержащий информацию о всех выданных книгах

    def save_to_file(self, filename): #Эта строка определяет метод save_to_file, который принимает один параметр filename — имя файла, в который будут сохранены данные библиотеки
        """Сохраняет данные библиотеки в файл."""
        data = { #Эта строка начинает создание словаря data, который будет содержать информацию о книгах и читателях библиотеки
            "books": [book.__dict__ for book in self.books],
            #В словаре создается ключ "books", которому присваивается список словарей, представляющих каждую книгу. Для каждой книги вызывается атрибут __dict__, который возвращает все атрибуты книги в виде словаря
            "readers": [ #Эта строка начинает создание списка читателей для ключа "readers"
                {
                    "first_name": reader.first_name,
                    "last_name": reader.last_name,
                    "card_number": reader.card_number,
                    "borrowed_books": [ #Эта строка начинает создание списка книг, выданных читателю, для ключа "borrowed_books"
                        {"title": b[0], "borrow_date": b[1].isoformat()} for b in reader.borrowed_books
                        #Для каждой книги, выданной читателю (представленной как кортеж), создается словарь с ключами "title" и "borrow_date". Ключу "title" присваивается название книги (b[0]), а ключу "borrow_date" — дата выдачи книги в формате ISO с помощью метода isoformat()
                    ] #Закрывающая скобка для списка выданных книг
                } for reader in self.readers #Закрывающая фигурная скобка для словаря читателя и завершение списка читателей. Для каждого читателя из списка self.readers создается соответствующий словарь
            ] #Закрывающая скобка для списка читателей
        } #Закрывающая фигурная скобка для словаря data
        with open(filename, "w") as file:
            #Открывает файл с именем filename в режиме записи ("w"). Если файл уже существует, он будет перезаписан. Переменная file ссылается на открытый файл
            json.dump(data, file) #Сериализует (преобразует) объект data в формат JSON и записывает его в открытый файл

    def load_from_file(self, filename): #Эта строка определяет метод load_from_file, который принимает один параметр filename — имя файла, из которого будут загружены данные библиотеки
        """Загружает данные библиотеки из файла."""
        with open(filename, "r") as file: #Открывает файл с именем filename в режиме чтения ("r"). Переменная file ссылается на открытый файл
            data = json.load(file) #Загружает данные из файла и десериализует их из формата JSON в объект Python (в данном случае это будет словарь). Результат сохраняется в переменной data
        self.books = [Book(**book) for book in data["books"]]
        #Обновляет атрибут экземпляра self.books, создавая новый список объектов класса Book. Для каждого элемента в списке книг из загруженных данных используется распаковка аргументов (**book), чтобы передать атрибуты книги в конструктор класса Book
        self.readers = [ #Эта строка начинает создание нового списка объектов класса Reader, который обновит атрибут экземпляра self.readers
            Reader( #Создание нового объекта класса Reader
                first_name=reader["first_name"], #Установка имени читателя из загруженных данных
                last_name=reader["last_name"],
                card_number=reader["card_number"],
                borrowed_books=[ #Начало создания списка книг, выданных читателю
                    (b["title"], datetime.fromisoformat(b["borrow_date"])) for b in reader["borrowed_books"]
                    #Для каждой выданной книги (представленной как словарь) создается кортеж, содержащий название книги и дату выдачи. Дата преобразуется из строки формата ISO обратно в объект datetime с помощью метода fromisoformat
                ]
            ) for reader in data["readers"] # Закрывающая скобка для создания объекта Reader и завершение списка читателей. Для каждого читателя из загруженных данных создается соответствующий объект класса Reader
        ] #Завершения списка читателей
